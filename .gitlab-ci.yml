workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "testing"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - when: never

stages:
  - validate
  - plan
  - approve
  - apply
  - deploy
  - cleanup

variables:
  AWS_REGION: "eu-central-1"
  EKS_CLUSTER_NAME: "my-eks-cluster"
  TF_IN_AUTOMATION: "true"

cache:
  key: terraform
  paths:
    - .terraform/

##################################
# 1) Validate Terraform
##################################
terraform-validate:
  stage: validate
  image: hashicorp/terraform:latest
  script:
    - terraform init -backend=false
    - terraform validate

##################################
# 2) Terraform Plan
##################################
terraform-plan:
  stage: plan
  image: hashicorp/terraform:latest
  script:
    - cd terraform
    - terraform init
    - terraform plan -var-file=terraform.tfvars -out=tfplan
  artifacts:
    paths:
      - terraform/tfplan

##################################
# 3) Terraform Apply (Capture Outputs)
##################################
terraform-apply:
  stage: apply
  image: hashicorp/terraform:latest
  needs: ["terraform-plan"]
  script:
    - cd terraform
    - terraform init
    - terraform apply -auto-approve tfplan
    # Save outputs to JSON file
    - terraform output -json > ../terraform_outputs.json
  artifacts:
    paths:
      - terraform_outputs.json  # Pass outputs to downstream jobs

##################################
# 4) Deploy Kubernetes Workloads
##################################
deploy-k8s:
  stage: deploy
  image: ubuntu:20.04
  needs: ["terraform-apply"]
  script:
    - apt-get update -y && apt-get install -y curl unzip
    # Install AWS CLI v2 and kubectl
    - curl -Lo awscliv2.zip https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip
    - unzip awscliv2.zip && ./aws/install
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl && mv kubectl /usr/local/bin/
    # Configure EKS access
    - aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME
    - kubectl apply -f k8s/namespace.yaml
    - kubectl apply -f k8s/

##################################
# 5) Deploy ECS Tasks (No Terraform!)
##################################
deploy-ecs:
  stage: deploy
  image: willhallonline/ansible:alpine
  needs: ["terraform-apply"]
  script:
    - apk add jq
    # Extract subnet IDs as JSON array
    - SUBNET_IDS=$(jq -c '.private_subnet_ids.value' terraform_outputs.json)
    # Extract other values
    - SECURITY_GROUP_IDS=$(jq -c '.ecs_security_group_id.value' terraform_outputs.json)
    - TASK_DEFINITION=$(jq -r '.ecs_task_definition.value' terraform_outputs.json)
    - ECS_CLUSTER=$(jq -r '.ecs_cluster_name.value' terraform_outputs.json)
    # Pass as JSON lists
    - ansible-playbook -i "localhost," -c local ansible/ecs-deploy.yaml
      --extra-vars "subnet_ids=$SUBNET_IDS
                    security_group_ids=$SECURITY_GROUP_IDS
                    task_definition='$TASK_DEFINITION'
                    ecs_cluster_name='$ECS_CLUSTER'"

##################################
# 6) Rollback Mechanism (On Failure)
##################################
rollback:
  stage: cleanup
  when: on_failure
  image: hashicorp/terraform:latest
  script:
    - terraform init
    - terraform destroy -auto-approve
    - apk update && apk add --no-cache curl python3 py3-pip
    - pip3 install ansible awscli
    - curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    - chmod +x kubectl && mv kubectl /usr/local/bin/
    - export DEBIAN_FRONTEND=noninteractive
    - apt-get update -y && apt-get install -y awscli
    - aws eks update-kubeconfig --region $AWS_REGION --name $EKS_CLUSTER_NAME
    - export KUBECONFIG=$HOME/.kube/config
    - sed -i 's/v1alpha1/v1beta1/g' $KUBECONFIG
    - kubectl delete -f k8s/ || true
    - ansible-playbook -i "localhost," -c local ansible/ecs-deploy.yaml --extra-vars "rollback=true"
